<!DOCTYPE html>
<html lang="en">
<head>
    <title>Draw elements</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #cccccc;
            font-family:Monospace;
            font-size:13px;
            text-align:center;

            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px; width: 100%;
            padding: 5px;
        }

        a {
            color: #0080ff;
        }

    </style>
</head>
<body>

<input id="InputFile" type="file" style="visibility:hidden" />


<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute float alpha;
    varying float vAlpha;

    attribute vec3 customColor;
    varying vec3 vColor;
    void main() {
        vAlpha = alpha;
        vColor = customColor;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_PointSize = size * ( 300.0 / -mvPosition.z );
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    varying float vAlpha;
    uniform vec3 color;
    uniform sampler2D texture;
    varying vec3 vColor;
    void main() {
        gl_FragColor = vec4( color * vColor, 1 );
        gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
        gl_FragColor.a = vAlpha;
    }
</script>


<div id="container"></div>

<script src="JsLib/dat.gui.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="JsLib/three.js"></script>
<script src="JsLib/OrbitControls.js"></script>
<script src="JsLib/stats.min.js"></script>

<script>

    var gui;

    var group;
    var container, controls, stats;
    var particlesData = [];
    var camera, scene, renderer;
    var positions, colorsLine, colorsPoints, alphaPoint;
    var particles;
    var pointCloud;
    var particlePositions;
    var particleSize;
    var linesMesh;

    var mapMesh = {};
    var previousValue;

    var maxParticleCount = 1000;
    var particleCount = 500;
    var r = 800;
    var rHalf = r / 2;



    var data = getData();
    var keys = Object.keys(data);
    keys.push("All");

    var effectController = {
        showDots: true,
        showLines: true,
        minDistance: 150,
        limitConnections: false,
        maxConnections: 20,
        particleCount: 500,
        template:keys,
        fileName : "Name",
        add:function(){ console.log("clicked")},
        loadFile:function(){
            var inputFile = document.getElementById('InputFile');
            inputFile.addEventListener('change', function() {
                var file = inputFile.files[0];
                effectController['fileName'] = file.name;
                // update all controllers

                for (var i in gui.__controllers) {
                    gui.__controllers[i].updateDisplay();
                }
                upload(file);
            });
            inputFile.click();
        }
    };

    initGUI();
    init();

    initAll(data);
    animate();

    function initGUI() {

        gui = new dat.GUI();

//        gui.add( effectController, "showDots" ).onChange( function( value ) { pointCloud.visible = value; } );
//        gui.add( effectController, "showLines" ).onChange( function( value ) { linesMesh.visible = value; } );
//        gui.add( effectController, "minDistance", 10, 300 );
//        gui.add( effectController, "limitConnections" );
//        gui.add( effectController, "maxConnections", 0, 30, 1 );
        gui.add( effectController, 'fileName');
        gui.add( effectController, 'loadFile'). name('Load CSV file');
        gui.add( effectController, 'template', effectController.template).onChange( function( value ) {
            if(previousValue==="All"){
                for (var key in mapMesh) {
                    var meshArray = mapMesh[key];
                    updateAlpha(meshArray, 0.2);
                }
                previousValue=null;
            }
            if(value==="All"){
                for (var key in mapMesh) {
                    var meshArray = mapMesh[key];
                    updateAlpha(meshArray, 1);
                }
            }
            else{
                var meshArray = mapMesh[value];
                updateAlpha(meshArray, 1);
                if(previousValue!=null){
                    var meshArrayPrev = mapMesh[previousValue];
                    updateAlpha(meshArrayPrev, 0.2);
                }
            }
            previousValue = value;
        }); // controller 1
        gui.add( effectController, "particleCount", 0, maxParticleCount, 1 ).onChange( function( value ) {
            particleCount = parseInt( value );
            particles.setDrawRange( 0, particleCount );
        });

        gui.add( effectController, "add");

    }

    function initAll(allObject) {
        for (var key1 in allObject) {
            initModel(allObject[key1], key1);
        }
    }

    function initModel(obj, modelName) {


        maxParticleCount = obj.points.length;

        var segments = maxParticleCount * maxParticleCount;

        positions = new Float32Array( segments * 3 );
        colorsLine = new Float32Array( segments * 3 );

        particlePositions = new Float32Array( maxParticleCount * 3 );
        colorsPoints = new Float32Array( maxParticleCount * 3 );
        particleSize = new Float32Array( maxParticleCount);
        alphaPoint = new Float32Array( maxParticleCount);

        var opacity = 0.2;

        var pMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                amplitude: { value: 1.0 },
                color:     { value: new THREE.Color( 0xff0000 ) },
                texture:   { value: new THREE.TextureLoader().load( "../content/disc.png" ) }
            },
            vertexShader:   document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
            blending:       THREE.AdditiveBlending,
            depthTest:      false,
            transparent:    true
        });

        particles = new THREE.BufferGeometry();


        var colorpos = 0;
        var vertexpos = 0;
        var points = [];

        for ( var i = 0; i < maxParticleCount; i++ ) {

            var x = obj.points[i].x;
            var y = obj.points[i].y;
            var z = obj.points[i].z;

            particlePositions[ i * 3     ] = x;
            particlePositions[ i * 3 + 1 ] = y;
            particlePositions[ i * 3 + 2 ] = z;

            colorsPoints[i * 3     ] = 1;
            colorsPoints[i * 3 + 1 ] = 1;
            colorsPoints[i * 3 + 2 ] = 1;

            alphaPoint[ i ] = opacity;
            particleSize[i] = obj.points[i].r*2;


            points.push(new THREE.Vector3(x, y, z));

            if(i==0){
                continue;
            }



            positions[ vertexpos++ ] = particlePositions[ i * 3     ];
            positions[ vertexpos++ ] = particlePositions[ i * 3 + 1 ];
            positions[ vertexpos++ ] = particlePositions[ i * 3 + 2 ];

            positions[ vertexpos++ ] = particlePositions[ (i-1) * 3     ];
            positions[ vertexpos++ ] = particlePositions[ (i-1) * 3 + 1 ];
            positions[ vertexpos++ ] = particlePositions[ (i-1) * 3 + 2 ];



            colorsLine[ colorpos++ ] = 1;
            colorsLine[ colorpos++ ] = 1;
            colorsLine[ colorpos++ ] = 1;

            colorsLine[ colorpos++ ] = 1;
            colorsLine[ colorpos++ ] = 1;
            colorsLine[ colorpos++ ] = 1;

        }

        particles.setDrawRange( 0, particleCount );
        particles.addAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setDynamic( true ) );
        particles.addAttribute( 'customColor', new THREE.BufferAttribute( colorsPoints, 3 ) );
        particles.addAttribute( 'size', new THREE.BufferAttribute( particleSize, 1 ).setDynamic( true ) );
        particles.addAttribute( 'alpha', new THREE.BufferAttribute( alphaPoint, 1 ).setDynamic( true ) );

        // create the particle system
        pointCloud = new THREE.Points( particles, pMaterial );
        group.add( pointCloud );

        var geometry = new THREE.BufferGeometry();

        var spline = new THREE.CatmullRomCurve3(points);
        var splinePoints = spline.getPoints(points.length*5);

        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setDynamic( true ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colorsLine, 3 ).setDynamic( true ) );

        geometry.computeBoundingSphere();

        geometry.setDrawRange( 0, 0 );

        var material = new THREE.LineBasicMaterial( {
            vertexColors: THREE.VertexColors,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity : opacity,
//            color: 0x00ffff
        } );

        linesMesh = new THREE.LineSegments( geometry, material );

        linesMesh.geometry.setDrawRange( 0, maxParticleCount * 2 );
        group.add( linesMesh );



        var material = new THREE.LineBasicMaterial({
            color: 0xff00f0,
            opacity: 0.2,
            transparent: true,
        });

        var geometry = new THREE.Geometry();

        for(var i = 0; i < splinePoints.length; i++){
            geometry.vertices.push(splinePoints[i]);
        }

        var line = new THREE.Line(geometry, material);
        scene.add(line);

        mapMesh[modelName] = [pointCloud, linesMesh, line];
    }

    function init() {

        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
        camera.position.z = 50;
        controls = new THREE.OrbitControls( camera, container, container);
        scene = new THREE.Scene();


        group = new THREE.Group();
        scene.add( group );

        var helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r ) ) );
        helper.material.color.setHex( 0x080808 );
        helper.material.blending = THREE.AdditiveBlending;
        helper.material.transparent = true;
        group.add( helper );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

        window.addEventListener( 'resize', onWindowResize, false );
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {
        requestAnimationFrame( animate );
        stats.update();
        render();

    }

    function render() {
        renderer.render( scene, camera );
    }

    function getData() {
        var jsonDataR;
        $.ajax({
            dataType: 'json',
            async: false,
            url: '/getPoints/test',
            success: function(jsondata){
                console.log("Data was received");
                console.log(Object.keys(jsondata));
                jsonDataR = jsondata;
            }
        });
        return jsonDataR;
    }

    function updateAlpha(model, value) {
        var points = model[0].geometry.attributes.alpha;
        for( var i = 0; i < points.array.length; i++ ) {
            points.array[ i ] = value;
        }
        points.needsUpdate = true;
        model[1].material.opacity = value;
        model[1].material.needsUpdate = true;

        model[2].material.opacity = value;
        model[2].material.needsUpdate = true;
    }

    function upload(file) {

        var xhr = new XMLHttpRequest();

        // обработчик для закачки
        xhr.upload.onprogress = function(event) {
            console.log(event.loaded + ' / ' + event.total);
        };

        // обработчики успеха и ошибки
        // если status == 200, то это успех, иначе ошибка
        xhr.onload = xhr.onerror = function() {
            if (this.status == 200) {
                console.log("success");
            } else {
                console.log("error " + this.status);
            }
        };

        xhr.open("POST", "upload", true);
        xhr.send(file);

    }

    //        positions = new Float32Array( splinePoints.length * 3);
    //        colorsLine = new Float32Array( splinePoints.length * 3 );
    //        splinePoints.forEach(function (item, i, arr) {
    //            positions[i] = item.x;
    //            positions[i+1] = item.y;
    //            positions[i+2] = item.z;
    //
    //            colorsLine[i]   = 1;
    //            colorsLine[i+1] = 1;
    //            colorsLine[i+2] = 1;
    //        });
</script>
</body>
</html>